from gmusicapi import Mobileclient
import re
import random
import getpass

plistDescStr = 'autogenerated'

class ClassyMixer(object):
    #TODO You shouldn't have to type your password in plain text. Prompt for
    # username and password.
    def __init__(self):
        # Acquire the api
        self.__api = Mobileclient()
        
        # Get the user's login info (username and password)
        username = raw_input("Google username:")
        if re.match(".*?@gmail.com", username) is None:
            username += "@gmail.com"
        password = getpass.getpass("Google password:")
        
        # Log into the api. Note that there is a warning that states the
        # connection is insecure when using Python 2.7. This should only be
        # mentioned once, not 3+ times, unfortunately I can't seem to catch the
        # exception.
        try:
            self.__api.login(username,password,Mobileclient.FROM_MAC_ADDRESS)
        except InsecurePlatformWarning:
            print("Note that, for security reasons, this would be better implemented in python 3")
        
        # Load the library
        self.library = self.__api.get_all_songs()
        
        # Load the list of playlists
        self.playlists = self.__api.get_all_playlists()
        return
    
    def __del__(self):
        self.__api.logout()
        return
    
    def update(self):
        self.library = self.__api.get_all_songs()
        self.playlists = self.__api.get_all_playlists()
        return
    
    def getList(self, initSongList = None, **criteria):
        if initSongList is None:
            initSongList = self.library
        
        songList = []
        for song in initSongList:
            # If any of the criteria are not met...
            for label, crit in criteria.iteritems():
                data = song[label]
                if isinstance(crit, re._pattern_type) and crit.match(data) is None:
                    break
                elif song[label] != crit:
                    break # Do nothing
            else: # Add the song to the list
                songList.append(song)
        return songList
    
    #TODO: generalize the genre categorization to include any other criteria for
    # sorting. I'm thinking a dict {<label>:<value,...} e.g. {'genre':'Classical'} 
    def getPieceDict(self, songList = None, **criteria):
        '''
        Create a dictionary of pieces, indexced by a tuple of album name and
        title. This will attempt to put movements of a piece together into
        one dictionary entry.
        
        For example: `Symphony No. 3 - 1. Allegro` and `Symphony No. 3 - 2. Adagio`
        on the album `Beethoven's Symphonies` should show up in the entry with key
        ('Beethoven's Symphonies', 'Symphony No. 3'), with a list of the movements
        as the item. Each element of the list is a tuple of the track number and
        the title.
        
        There are three regex patterns used to pick out these pieces.
        
        INPUTS: 
        (Note: please provide only one. songList takes precedence. If neither is
        provided, then the entire library will be used.)
        songList -- (default None) a list of song data compiled by the user. This 
                    must at least have the entries: 'album', 'title', and 
                    'trackNumber'.
        **criteria -- add arguments (e.g. genre = 'Classical') to limit the scope
                    of this function based off of track metadata. This argument is
                    passed direction to the getList method. If songList is given,
                    then criteria are applied to the songList
        
        OUTPUTS:
        songDict -- a dictionary indexed by a tuple with the album and song titles
                    containing lists of tracks that belong in each piece.
        '''
        # Get the songList, if not provided.
        songList = self.getList(initSongList = songList, **criteria)
        
        # Define the regex patterns to pick out movements of larger pieces.
        pattList = []
        # With numbers (including roman numerals)
        pattList.append(re.compile("(.*)[ -:]+?(\d+)[.:]? *?(\w+.*)"))
        pattList.append(re.compile("(.*)[ -:]+?([IVX]+)[.:]? *?(\w+.*)"))
        # Without numbers
        pattList.append(re.compile("(.*) *?([:;]) *?(\w+.*)"))
        pattList.append(re.compile("(.*)( +?- *?| *?- +?)(\w+.*)"))
        
        # Build the songDict.
        songDict = {}
        for song in songList:
            # Get the full title.
            fulltitle = song['title']
            
            # Get the matches to the patterns. Only keep the ones where we
            # actually got a match.
            mList = []
            for i, patt in enumerate(pattList):
                m = patt.findall(fulltitle)
                if len(m):
                    mList.append(m)
            
            # This is the core of where we decide how to sort the pieces.
            #TODO: Make this better.
            if len(mList):
                toptitle = (song['album'], mList[0][0][0])
                subtitle = (song['trackNumber'], mList[0][0][-1])
                
                # As of now this is really poorly handled...but it seems to work
                # remarkably well.
                #if len(mList) is not 1:
                #    print "Multiple matches for", fulltitle
            else:
                toptitle = (song['album'], fulltitle)
            
            # Here we actually make the entry in the dict.
            entry = (subtitle, song['id'])
            if songDict.has_key(toptitle):
                songDict[toptitle].append(entry)
            else:
                songDict[toptitle] = [entry]
        
        return songDict
    
    #TODO: this needs to be generalized somehow. I want to be able to write
    # playlists for arbitray systems, e.g. iTunes and Google Play. It is currently
    # set up to use Google play.
    def writePlaylist(self, name, playlist, update = False):
        '''
        This is the function to actually writes the playlist.
        
        INPUTS:
        name        -- the name of the new playlist
        playlist    -- the actualy list of pid's to be used to create the playlist
        
        OUTPUS:
        None
        '''
        # Check to see if the playlist already exists.
        nOld = 0
        pattStr = '%s {0,1}\({0,1}(\d*)\){0,1}' % name
        for plDesc in self.playlists:
            # If it does (or some number <name> (#) of the name does)
            if re.match(pattStr, plDesc['name']) is not None:
                # If this program made it, and we're updating, then overwrite.
                if plDesc['description'] == plistDescStr and update:
                    self.__api.delete_playlist(plDesc['id'])
                    break
                # Otherwise, make a one with a higher number. More particularly
                # I'm just seeing what numbers are out there, and over the course
                # of this for-loop, I recall which was the biggest, and I make one
                # that is one bigger.
                else:
                    nRe = re.findall(pattStr, plDesc['name'])
                    if nRe[0] != '':
                        nNew = int(nRe[0]) + 1
                    else:
                        nNew = 1
                    if nNew > nOld:
                        nOld = nNew
        
        # Set the name based on what we decided above.
        name = '%s (%d)' % (name, nOld)
        
        # Make the playlist
        pid = self.__api.create_playlist(name, description = plistDescStr)
        
        # Populate the playlist.
        self.__api.add_songs_to_playlist(pid, playlist)
        
        return
    
    def mix(self, name, numPieces, *args, **kwargs):
        '''
        
        '''
        # Get the value for update, or set it to its default.
        if kwargs.has_key('update'):
            update = kwargs.pop('update')
        else:
            update = False
        
        # Get the dictionary of relevant songs (indicated by *args and **kwargs)
        # indexed by piece (e.g. 'Beethoven Symphony No. 3').
        songDict = self.getPieceDict(*args, **kwargs)
        
        # Get the List Of Pieces (lop) and shuffle it.
        lop = songDict.keys()
        random.shuffle(lop)
        
        # Now build the playlist.
        playlist = []
        for toptitle in lop[:numPieces]:
            subList = []
            for subtitle, sid in songDict[toptitle]:
                subList.append((subtitle, sid))
            subList.sort()
            for _, sid in subList:
                playlist.append(sid)
        
        # Now actually create the playlist.
        self.writePlaylist(name, playlist, update)
        
        return lop
